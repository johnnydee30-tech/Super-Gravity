SCRIPTS = {'chrome_csi': "if (!window.chrome) {\r\n    // Use the exact property descriptor found in headful Chrome\r\n    // fetch it via `Object.getOwnPropertyDescriptor(window, 'chrome')`\r\n    Object.defineProperty(window, 'chrome', {\r\n        writable: true,\r\n        enumerable: true,\r\n        configurable: false, // note!\r\n        value: {} // We'll extend that later\r\n    })\r\n}\r\n\r\n// Check if we're running headful and don't need to mock anything\r\n// Check that the Navigation Timing API v1 is available, we need that\r\nif (!('csi' in window.chrome) && (window.performance || window.performance.timing)) {\r\n    const {csi_timing} = window.performance\r\n\r\n    log.info('loading chrome.csi.js')\r\n    window.chrome.csi = function () {\r\n        return {\r\n            onloadT: csi_timing.domContentLoadedEventEnd,\r\n            startE: csi_timing.navigationStart,\r\n            pageT: Date.now() - csi_timing.navigationStart,\r\n            tran: 15 // Transition type or something\r\n        }\r\n    }\r\n    utils.patchToString(window.chrome.csi)\r\n}", 'chrome_app': 'if (!window.chrome) {\r\n    // Use the exact property descriptor found in headful Chrome\r\n    // fetch it via `Object.getOwnPropertyDescriptor(window, \'chrome\')`\r\n    Object.defineProperty(window, \'chrome\', {\r\n        writable: true,\r\n        enumerable: true,\r\n        configurable: false, // note!\r\n        value: {} // We\'ll extend that later\r\n    })\r\n}\r\n\r\n// app in window.chrome means we\'re running headful and don\'t need to mock anything\r\nif (!(\'app\' in window.chrome)) {\r\n    const makeError = {\r\n        ErrorInInvocation: fn => {\r\n            const err = new TypeError(`Error in invocation of app.${fn}()`)\r\n            return utils.stripErrorWithAnchor(\r\n                err,\r\n                `at ${fn} (eval at <anonymous>`\r\n            )\r\n        }\r\n    }\r\n\r\n// There\'s a some static data in that property which doesn\'t seem to change,\r\n// we should periodically check for updates: `JSON.stringify(window.app, null, 2)`\r\n    const APP_STATIC_DATA = JSON.parse(\r\n        `\r\n{\r\n  "isInstalled": false,\r\n  "InstallState": {\r\n    "DISABLED": "disabled",\r\n    "INSTALLED": "installed",\r\n    "NOT_INSTALLED": "not_installed"\r\n  },\r\n  "RunningState": {\r\n    "CANNOT_RUN": "cannot_run",\r\n    "READY_TO_RUN": "ready_to_run",\r\n    "RUNNING": "running"\r\n  }\r\n}\r\n        `.trim()\r\n    )\r\n\r\n    window.chrome.app = {\r\n        ...APP_STATIC_DATA,\r\n\r\n        get isInstalled() {\r\n            return false\r\n        },\r\n\r\n        getDetails: function getDetails() {\r\n            if (arguments.length) {\r\n                throw makeError.ErrorInInvocation(`getDetails`)\r\n            }\r\n            return null\r\n        },\r\n        getIsInstalled: function getDetails() {\r\n            if (arguments.length) {\r\n                throw makeError.ErrorInInvocation(`getIsInstalled`)\r\n            }\r\n            return false\r\n        },\r\n        runningState: function getDetails() {\r\n            if (arguments.length) {\r\n                throw makeError.ErrorInInvocation(`runningState`)\r\n            }\r\n            return \'cannot_run\'\r\n        }\r\n    }\r\n    utils.patchToStringNested(window.chrome.app)\r\n}', 'chrome_runtime': 'const STATIC_DATA = {\r\n    "OnInstalledReason": {\r\n        "CHROME_UPDATE": "chrome_update",\r\n        "INSTALL": "install",\r\n        "SHARED_MODULE_UPDATE": "shared_module_update",\r\n        "UPDATE": "update"\r\n    },\r\n    "OnRestartRequiredReason": {\r\n        "APP_UPDATE": "app_update",\r\n        "OS_UPDATE": "os_update",\r\n        "PERIODIC": "periodic"\r\n    },\r\n    "PlatformArch": {\r\n        "ARM": "arm",\r\n        "ARM64": "arm64",\r\n        "MIPS": "mips",\r\n        "MIPS64": "mips64",\r\n        "X86_32": "x86-32",\r\n        "X86_64": "x86-64"\r\n    },\r\n    "PlatformNaclArch": {\r\n        "ARM": "arm",\r\n        "MIPS": "mips",\r\n        "MIPS64": "mips64",\r\n        "X86_32": "x86-32",\r\n        "X86_64": "x86-64"\r\n    },\r\n    "PlatformOs": {\r\n        "ANDROID": "android",\r\n        "CROS": "cros",\r\n        "LINUX": "linux",\r\n        "MAC": "mac",\r\n        "OPENBSD": "openbsd",\r\n        "WIN": "win"\r\n    },\r\n    "RequestUpdateCheckStatus": {\r\n        "NO_UPDATE": "no_update",\r\n        "THROTTLED": "throttled",\r\n        "UPDATE_AVAILABLE": "update_available"\r\n    }\r\n}\r\n\r\nif (!window.chrome) {\r\n    // Use the exact property descriptor found in headful Chrome\r\n    // fetch it via `Object.getOwnPropertyDescriptor(window, \'chrome\')`\r\n    Object.defineProperty(window, \'chrome\', {\r\n        writable: true,\r\n        enumerable: true,\r\n        configurable: false, // note!\r\n        value: {} // We\'ll extend that later\r\n    })\r\n}\r\n\r\n// That means we\'re running headfull and don\'t need to mock anything\r\nconst existsAlready = \'runtime\' in window.chrome\r\n// `chrome.runtime` is only exposed on secure origins\r\nconst isNotSecure = !window.location.protocol.startsWith(\'https\')\r\nif (!(existsAlready || (isNotSecure && !opts.runOnInsecureOrigins))) {\r\n    window.chrome.runtime = {\r\n        // There\'s a bunch of static data in that property which doesn\'t seem to change,\r\n        // we should periodically check for updates: `JSON.stringify(window.chrome.runtime, null, 2)`\r\n        ...STATIC_DATA,\r\n        // `chrome.runtime.id` is extension related and returns undefined in Chrome\r\n        get id() {\r\n            return undefined\r\n        },\r\n        // These two require more sophisticated mocks\r\n        connect: null,\r\n        sendMessage: null\r\n    }\r\n\r\n    const makeCustomRuntimeErrors = (preamble, method, extensionId) => ({\r\n        NoMatchingSignature: new TypeError(\r\n            preamble + `No matching signature.`\r\n        ),\r\n        MustSpecifyExtensionID: new TypeError(\r\n            preamble +\r\n            `${method} called from a webpage must specify an Extension ID (string) for its first argument.`\r\n        ),\r\n        InvalidExtensionID: new TypeError(\r\n            preamble + `Invalid extension id: \'${extensionId}\'`\r\n        )\r\n    })\r\n\r\n    // Valid Extension IDs are 32 characters in length and use the letter `a` to `p`:\r\n    // https://source.chromium.org/chromium/chromium/src/+/master:components/crx_file/id_util.cc;drc=14a055ccb17e8c8d5d437fe080faba4c6f07beac;l=90\r\n    const isValidExtensionID = str =>\r\n        str.length === 32 && str.toLowerCase().match(/^[a-p]+$/)\r\n\r\n    /** Mock `chrome.runtime.sendMessage` */\r\n    const sendMessageHandler = {\r\n        apply: function (target, ctx, args) {\r\n            const [extensionId, options, responseCallback] = args || []\r\n\r\n            // Define custom errors\r\n            const errorPreamble = `Error in invocation of runtime.sendMessage(optional string extensionId, any message, optional object options, optional function responseCallback): `\r\n            const Errors = makeCustomRuntimeErrors(\r\n                errorPreamble,\r\n                `chrome.runtime.sendMessage()`,\r\n                extensionId\r\n            )\r\n\r\n            // Check if the call signature looks ok\r\n            const noArguments = args.length === 0\r\n            const tooManyArguments = args.length > 4\r\n            const incorrectOptions = options && typeof options !== \'object\'\r\n            const incorrectResponseCallback =\r\n                responseCallback && typeof responseCallback !== \'function\'\r\n            if (\r\n                noArguments ||\r\n                tooManyArguments ||\r\n                incorrectOptions ||\r\n                incorrectResponseCallback\r\n            ) {\r\n                throw Errors.NoMatchingSignature\r\n            }\r\n\r\n            // At least 2 arguments are required before we even validate the extension ID\r\n            if (args.length < 2) {\r\n                throw Errors.MustSpecifyExtensionID\r\n            }\r\n\r\n            // Now let\'s make sure we got a string as extension ID\r\n            if (typeof extensionId !== \'string\') {\r\n                throw Errors.NoMatchingSignature\r\n            }\r\n\r\n            if (!isValidExtensionID(extensionId)) {\r\n                throw Errors.InvalidExtensionID\r\n            }\r\n\r\n            return undefined // Normal behavior\r\n        }\r\n    }\r\n    utils.mockWithProxy(\r\n        window.chrome.runtime,\r\n        \'sendMessage\',\r\n        function sendMessage() {\r\n        },\r\n        sendMessageHandler\r\n    )\r\n\r\n    /**\r\n     * Mock `chrome.runtime.connect`\r\n     *\r\n     * @see https://developer.chrome.com/apps/runtime#method-connect\r\n     */\r\n    const connectHandler = {\r\n        apply: function (target, ctx, args) {\r\n            const [extensionId, connectInfo] = args || []\r\n\r\n            // Define custom errors\r\n            const errorPreamble = `Error in invocation of runtime.connect(optional string extensionId, optional object connectInfo): `\r\n            const Errors = makeCustomRuntimeErrors(\r\n                errorPreamble,\r\n                `chrome.runtime.connect()`,\r\n                extensionId\r\n            )\r\n\r\n            // Behavior differs a bit from sendMessage:\r\n            const noArguments = args.length === 0\r\n            const emptyStringArgument = args.length === 1 && extensionId === \'\'\r\n            if (noArguments || emptyStringArgument) {\r\n                throw Errors.MustSpecifyExtensionID\r\n            }\r\n\r\n            const tooManyArguments = args.length > 2\r\n            const incorrectConnectInfoType =\r\n                connectInfo && typeof connectInfo !== \'object\'\r\n\r\n            if (tooManyArguments || incorrectConnectInfoType) {\r\n                throw Errors.NoMatchingSignature\r\n            }\r\n\r\n            const extensionIdIsString = typeof extensionId === \'string\'\r\n            if (extensionIdIsString && extensionId === \'\') {\r\n                throw Errors.MustSpecifyExtensionID\r\n            }\r\n            if (extensionIdIsString && !isValidExtensionID(extensionId)) {\r\n                throw Errors.InvalidExtensionID\r\n            }\r\n\r\n            // There\'s another edge-case here: extensionId is optional so we might find a connectInfo object as first param, which we need to validate\r\n            const validateConnectInfo = ci => {\r\n                // More than a first param connectInfo as been provided\r\n                if (args.length > 1) {\r\n                    throw Errors.NoMatchingSignature\r\n                }\r\n                // An empty connectInfo has been provided\r\n                if (Object.keys(ci).length === 0) {\r\n                    throw Errors.MustSpecifyExtensionID\r\n                }\r\n                // Loop over all connectInfo props an check them\r\n                Object.entries(ci).forEach(([k, v]) => {\r\n                    const isExpected = [\'name\', \'includeTlsChannelId\'].includes(k)\r\n                    if (!isExpected) {\r\n                        throw new TypeError(\r\n                            errorPreamble + `Unexpected property: \'${k}\'.`\r\n                        )\r\n                    }\r\n                    const MismatchError = (propName, expected, found) =>\r\n                        TypeError(\r\n                            errorPreamble +\r\n                            `Error at property \'${propName}\': Invalid type: expected ${expected}, found ${found}.`\r\n                        )\r\n                    if (k === \'name\' && typeof v !== \'string\') {\r\n                        throw MismatchError(k, \'string\', typeof v)\r\n                    }\r\n                    if (k === \'includeTlsChannelId\' && typeof v !== \'boolean\') {\r\n                        throw MismatchError(k, \'boolean\', typeof v)\r\n                    }\r\n                })\r\n            }\r\n            if (typeof extensionId === \'object\') {\r\n                validateConnectInfo(extensionId)\r\n                throw Errors.MustSpecifyExtensionID\r\n            }\r\n\r\n            // Unfortunately even when the connect fails Chrome will return an object with methods we need to mock as well\r\n            return utils.patchToStringNested(makeConnectResponse())\r\n        }\r\n    }\r\n    utils.mockWithProxy(\r\n        window.chrome.runtime,\r\n        \'connect\',\r\n        function connect() {\r\n        },\r\n        connectHandler\r\n    )\r\n\r\n    function makeConnectResponse() {\r\n        const onSomething = () => ({\r\n            addListener: function addListener() {\r\n            },\r\n            dispatch: function dispatch() {\r\n            },\r\n            hasListener: function hasListener() {\r\n            },\r\n            hasListeners: function hasListeners() {\r\n                return false\r\n            },\r\n            removeListener: function removeListener() {\r\n            }\r\n        })\r\n\r\n        const response = {\r\n            name: \'\',\r\n            sender: undefined,\r\n            disconnect: function disconnect() {\r\n            },\r\n            onDisconnect: onSomething(),\r\n            onMessage: onSomething(),\r\n            postMessage: function postMessage() {\r\n                if (!arguments.length) {\r\n                    throw new TypeError(`Insufficient number of arguments.`)\r\n                }\r\n                throw new Error(`Attempting to use a disconnected port object`)\r\n            }\r\n        }\r\n        return response\r\n    }\r\n}\r\n', 'chrome_load_times': "if (!window.chrome) {\r\n    // Use the exact property descriptor found in headful Chrome\r\n    // fetch it via `Object.getOwnPropertyDescriptor(window, 'chrome')`\r\n    Object.defineProperty(window, 'chrome', {\r\n        writable: true,\r\n        enumerable: true,\r\n        configurable: false, // note!\r\n        value: {} // We'll extend that later\r\n    })\r\n}\r\n\r\n// That means we're running headful and don't need to mock anything\r\nif ('loadTimes' in window.chrome) {\r\n    throw new Error('skipping chrome loadtimes update, running in headfull mode')\r\n}\r\n\r\n// Check that the Navigation Timing API v1 + v2 is available, we need that\r\nif (\r\n    window.performance ||\r\n    window.performance.timing ||\r\n    window.PerformancePaintTiming\r\n) {\r\n\r\n    const {performance} = window\r\n\r\n    // Some stuff is not available on about:blank as it requires a navigation to occur,\r\n    // let's harden the code to not fail then:\r\n    const ntEntryFallback = {\r\n        nextHopProtocol: 'h2',\r\n        type: 'other'\r\n    }\r\n\r\n    // The API exposes some funky info regarding the connection\r\n    const protocolInfo = {\r\n        get connectionInfo() {\r\n            const ntEntry =\r\n                performance.getEntriesByType('navigation')[0] || ntEntryFallback\r\n            return ntEntry.nextHopProtocol\r\n        },\r\n        get npnNegotiatedProtocol() {\r\n            // NPN is deprecated in favor of ALPN, but this implementation returns the\r\n            // HTTP/2 or HTTP2+QUIC/39 requests negotiated via ALPN.\r\n            const ntEntry =\r\n                performance.getEntriesByType('navigation')[0] || ntEntryFallback\r\n            return ['h2', 'hq'].includes(ntEntry.nextHopProtocol)\r\n                ? ntEntry.nextHopProtocol\r\n                : 'unknown'\r\n        },\r\n        get navigationType() {\r\n            const ntEntry =\r\n                performance.getEntriesByType('navigation')[0] || ntEntryFallback\r\n            return ntEntry.type\r\n        },\r\n        get wasAlternateProtocolAvailable() {\r\n            // The Alternate-Protocol header is deprecated in favor of Alt-Svc\r\n            // (https://www.mnot.net/blog/2016/03/09/alt-svc), so technically this\r\n            // should always return false.\r\n            return false\r\n        },\r\n        get wasFetchedViaSpdy() {\r\n            // SPDY is deprecated in favor of HTTP/2, but this implementation returns\r\n            // true for HTTP/2 or HTTP2+QUIC/39 as well.\r\n            const ntEntry =\r\n                performance.getEntriesByType('navigation')[0] || ntEntryFallback\r\n            return ['h2', 'hq'].includes(ntEntry.nextHopProtocol)\r\n        },\r\n        get wasNpnNegotiated() {\r\n            // NPN is deprecated in favor of ALPN, but this implementation returns true\r\n            // for HTTP/2 or HTTP2+QUIC/39 requests negotiated via ALPN.\r\n            const ntEntry =\r\n                performance.getEntriesByType('navigation')[0] || ntEntryFallback\r\n            return ['h2', 'hq'].includes(ntEntry.nextHopProtocol)\r\n        }\r\n    }\r\n\r\n    const {timing} = window.performance\r\n\r\n// Truncate number to specific number of decimals, most of the `loadTimes` stuff has 3\r\n    function toFixed(num, fixed) {\r\n        var re = new RegExp('^-?\\\\d+(?:.\\\\d{0,' + (fixed || -1) + '})?')\r\n        return num.toString().match(re)[0]\r\n    }\r\n\r\n    const timingInfo = {\r\n        get firstPaintAfterLoadTime() {\r\n            // This was never actually implemented and always returns 0.\r\n            return 0\r\n        },\r\n        get requestTime() {\r\n            return timing.navigationStart / 1000\r\n        },\r\n        get startLoadTime() {\r\n            return timing.navigationStart / 1000\r\n        },\r\n        get commitLoadTime() {\r\n            return timing.responseStart / 1000\r\n        },\r\n        get finishDocumentLoadTime() {\r\n            return timing.domContentLoadedEventEnd / 1000\r\n        },\r\n        get finishLoadTime() {\r\n            return timing.loadEventEnd / 1000\r\n        },\r\n        get firstPaintTime() {\r\n            const fpEntry = performance.getEntriesByType('paint')[0] || {\r\n                startTime: timing.loadEventEnd / 1000 // Fallback if no navigation occured (`about:blank`)\r\n            }\r\n            return toFixed(\r\n                (fpEntry.startTime + performance.timeOrigin) / 1000,\r\n                3\r\n            )\r\n        }\r\n    }\r\n\r\n    window.chrome.loadTimes = function () {\r\n        return {\r\n            ...protocolInfo,\r\n            ...timingInfo\r\n        }\r\n    }\r\n    utils.patchToString(window.chrome.loadTimes)\r\n}", 'chrome_hairline': "// https://intoli.com/blog/making-chrome-headless-undetectable/\r\n// store the existing descriptor\r\nconst elementDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'offsetHeight');\r\n\r\n// redefine the property with a patched descriptor\r\nObject.defineProperty(HTMLDivElement.prototype, 'offsetHeight', {\r\n  ...elementDescriptor,\r\n  get: function() {\r\n    if (this.id === 'modernizr') {\r\n        return 1;\r\n    }\r\n    return elementDescriptor.get.apply(this);\r\n  },\r\n});", 'generate_magic_arrays': 'generateFunctionMocks = (\r\n    proto,\r\n    itemMainProp,\r\n    dataArray\r\n) => ({\r\n    item: utils.createProxy(proto.item, {\r\n        apply(target, ctx, args) {\r\n            if (!args.length) {\r\n                throw new TypeError(\r\n                    `Failed to execute \'item\' on \'${\r\n                        proto[Symbol.toStringTag]\r\n                    }\': 1 argument required, but only 0 present.`\r\n                )\r\n            }\r\n            // Special behavior alert:\r\n            // - Vanilla tries to cast strings to Numbers (only integers!) and use them as property index lookup\r\n            // - If anything else than an integer (including as string) is provided it will return the first entry\r\n            const isInteger = args[0] && Number.isInteger(Number(args[0])) // Cast potential string to number first, then check for integer\r\n            // Note: Vanilla never returns `undefined`\r\n            return (isInteger ? dataArray[Number(args[0])] : dataArray[0]) || null\r\n        }\r\n    }),\r\n    /** Returns the MimeType object with the specified name. */\r\n    namedItem: utils.createProxy(proto.namedItem, {\r\n        apply(target, ctx, args) {\r\n            if (!args.length) {\r\n                throw new TypeError(\r\n                    `Failed to execute \'namedItem\' on \'${\r\n                        proto[Symbol.toStringTag]\r\n                    }\': 1 argument required, but only 0 present.`\r\n                )\r\n            }\r\n            return dataArray.find(mt => mt[itemMainProp] === args[0]) || null // Not `undefined`!\r\n        }\r\n    }),\r\n    /** Does nothing and shall return nothing */\r\n    refresh: proto.refresh\r\n        ? utils.createProxy(proto.refresh, {\r\n            apply(target, ctx, args) {\r\n                return undefined\r\n            }\r\n        })\r\n        : undefined\r\n})\r\n\r\nfunction generateMagicArray(\r\n    dataArray = [],\r\n    proto = MimeTypeArray.prototype,\r\n    itemProto = MimeType.prototype,\r\n    itemMainProp = \'type\'\r\n) {\r\n    // Quick helper to set props with the same descriptors vanilla is using\r\n    const defineProp = (obj, prop, value) =>\r\n        Object.defineProperty(obj, prop, {\r\n            value,\r\n            writable: false,\r\n            enumerable: false, // Important for mimeTypes & plugins: `JSON.stringify(navigator.mimeTypes)`\r\n            configurable: false\r\n        })\r\n\r\n    // Loop over our fake data and construct items\r\n    const makeItem = data => {\r\n        const item = {}\r\n        for (const prop of Object.keys(data)) {\r\n            if (prop.startsWith(\'__\')) {\r\n                continue\r\n            }\r\n            defineProp(item, prop, data[prop])\r\n        }\r\n        // navigator.plugins[i].length should always be 1\r\n        if (itemProto === Plugin.prototype) {\r\n            defineProp(item, \'length\', 1)\r\n        }\r\n        // We need to spoof a specific `MimeType` or `Plugin` object\r\n        return Object.create(itemProto, Object.getOwnPropertyDescriptors(item))\r\n    }\r\n\r\n    const magicArray = []\r\n\r\n    // Loop through our fake data and use that to create convincing entities\r\n    dataArray.forEach(data => {\r\n        magicArray.push(makeItem(data))\r\n    })\r\n\r\n    // Add direct property access  based on types (e.g. `obj[\'application/pdf\']`) afterwards\r\n    magicArray.forEach(entry => {\r\n        defineProp(magicArray, entry[itemMainProp], entry)\r\n    })\r\n\r\n    // This is the best way to fake the type to make sure this is false: `Array.isArray(navigator.mimeTypes)`\r\n    const magicArrayObj = Object.create(proto, {\r\n        ...Object.getOwnPropertyDescriptors(magicArray),\r\n\r\n        // There\'s one ugly quirk we unfortunately need to take care of:\r\n        // The `MimeTypeArray` prototype has an enumerable `length` property,\r\n        // but headful Chrome will still skip it when running `Object.getOwnPropertyNames(navigator.mimeTypes)`.\r\n        // To strip it we need to make it first `configurable` and can then overlay a Proxy with an `ownKeys` trap.\r\n        length: {\r\n            value: magicArray.length,\r\n            writable: false,\r\n            enumerable: false,\r\n            configurable: true // Important to be able to use the ownKeys trap in a Proxy to strip `length`\r\n        }\r\n    })\r\n\r\n    // Generate our functional function mocks :-)\r\n    const functionMocks = generateFunctionMocks(\r\n        proto,\r\n        itemMainProp,\r\n        magicArray\r\n    )\r\n\r\n    // Override custom object with proxy\r\n    return new Proxy(magicArrayObj, {\r\n        get(target, key = \'\') {\r\n            // Redirect function calls to our custom proxied versions mocking the vanilla behavior\r\n            if (key === \'item\') {\r\n                return functionMocks.item\r\n            }\r\n            if (key === \'namedItem\') {\r\n                return functionMocks.namedItem\r\n            }\r\n            if (proto === PluginArray.prototype && key === \'refresh\') {\r\n                return functionMocks.refresh\r\n            }\r\n            // Everything else can pass through as normal\r\n            return utils.cache.Reflect.get(...arguments)\r\n        },\r\n        ownKeys(target) {\r\n            // There are a couple of quirks where the original property demonstrates "magical" behavior that makes no sense\r\n            // This can be witnessed when calling `Object.getOwnPropertyNames(navigator.mimeTypes)` and the absense of `length`\r\n            // My guess is that it has to do with the recent change of not allowing data enumeration and this being implemented weirdly\r\n            // For that reason we just completely fake the available property names based on our data to match what regular Chrome is doing\r\n            // Specific issues when not patching this: `length` property is available, direct `types` props (e.g. `obj[\'application/pdf\']`) are missing\r\n            const keys = []\r\n            const typeProps = magicArray.map(mt => mt[itemMainProp])\r\n            typeProps.forEach((_, i) => keys.push(`${i}`))\r\n            typeProps.forEach(propName => keys.push(propName))\r\n            return keys\r\n        }\r\n    })\r\n}', 'iframe_content_window': "try {\r\n    // Adds a contentWindow proxy to the provided iframe element\r\n    const addContentWindowProxy = iframe => {\r\n        const contentWindowProxy = {\r\n            get(target, key) {\r\n                // Now to the interesting part:\r\n                // We actually make this thing behave like a regular iframe window,\r\n                // by intercepting calls to e.g. `.self` and redirect it to the correct thing. :)\r\n                // That makes it possible for these assertions to be correct:\r\n                // iframe.contentWindow.self === window.top // must be false\r\n                if (key === 'self') {\r\n                    return this\r\n                }\r\n                // iframe.contentWindow.frameElement === iframe // must be true\r\n                if (key === 'frameElement') {\r\n                    return iframe\r\n                }\r\n                return Reflect.get(target, key)\r\n            }\r\n        }\r\n\r\n        if (!iframe.contentWindow) {\r\n            const proxy = new Proxy(window, contentWindowProxy)\r\n            Object.defineProperty(iframe, 'contentWindow', {\r\n                get() {\r\n                    return proxy\r\n                },\r\n                set(newValue) {\r\n                    return newValue // contentWindow is immutable\r\n                },\r\n                enumerable: true,\r\n                configurable: false\r\n            })\r\n        }\r\n    }\r\n\r\n    // Handles iframe element creation, augments `srcdoc` property so we can intercept further\r\n    const handleIframeCreation = (target, thisArg, args) => {\r\n        const iframe = target.apply(thisArg, args)\r\n\r\n        // We need to keep the originals around\r\n        const _iframe = iframe\r\n        const _srcdoc = _iframe.srcdoc\r\n\r\n        // Add hook for the srcdoc property\r\n        // We need to be very surgical here to not break other iframes by accident\r\n        Object.defineProperty(iframe, 'srcdoc', {\r\n            configurable: true, // Important, so we can reset this later\r\n            get: function () {\r\n                return _iframe.srcdoc\r\n            },\r\n            set: function (newValue) {\r\n                addContentWindowProxy(this)\r\n                // Reset property, the hook is only needed once\r\n                Object.defineProperty(iframe, 'srcdoc', {\r\n                    configurable: false,\r\n                    writable: false,\r\n                    value: _srcdoc\r\n                })\r\n                _iframe.srcdoc = newValue\r\n            }\r\n        })\r\n        return iframe\r\n    }\r\n\r\n    // Adds a hook to intercept iframe creation events\r\n    const addIframeCreationSniffer = () => {\r\n        /* global document */\r\n        const createElementHandler = {\r\n            // Make toString() native\r\n            get(target, key) {\r\n                return Reflect.get(target, key)\r\n            },\r\n            apply: function (target, thisArg, args) {\r\n                const isIframe =\r\n                    args && args.length && `${args[0]}`.toLowerCase() === 'iframe'\r\n                if (!isIframe) {\r\n                    // Everything as usual\r\n                    return target.apply(thisArg, args)\r\n                } else {\r\n                    return handleIframeCreation(target, thisArg, args)\r\n                }\r\n            }\r\n        }\r\n        // All this just due to iframes with srcdoc bug\r\n        utils.replaceWithProxy(\r\n            document,\r\n            'createElement',\r\n            createElementHandler\r\n          )\r\n    }\r\n\r\n    // Let's go\r\n    addIframeCreationSniffer()\r\n} catch (err) {\r\n    // console.warn(err)\r\n}", 'media_codecs': '/**\r\n * Input might look funky, we need to normalize it so e.g. whitespace isn\'t an issue for our spoofing.\r\n *\r\n * @example\r\n * video/webm; codecs="vp8, vorbis"\r\n * video/mp4; codecs="avc1.42E01E"\r\n * audio/x-m4a;\r\n * audio/ogg; codecs="vorbis"\r\n * @param {String} arg\r\n */\r\nconst parseInput = arg => {\r\n    const [mime, codecStr] = arg.trim().split(\';\')\r\n    let codecs = []\r\n    if (codecStr && codecStr.includes(\'codecs="\')) {\r\n        codecs = codecStr\r\n            .trim()\r\n            .replace(`codecs="`, \'\')\r\n            .replace(`"`, \'\')\r\n            .trim()\r\n            .split(\',\')\r\n            .filter(x => !!x)\r\n            .map(x => x.trim())\r\n    }\r\n    return {\r\n        mime,\r\n        codecStr,\r\n        codecs\r\n    }\r\n}\r\n\r\nconst canPlayType = {\r\n    // Intercept certain requests\r\n    apply: function (target, ctx, args) {\r\n        if (!args || !args.length) {\r\n            return target.apply(ctx, args)\r\n        }\r\n        const {mime, codecs} = parseInput(args[0])\r\n        // This specific mp4 codec is missing in Chromium\r\n        if (mime === \'video/mp4\') {\r\n            if (codecs.includes(\'avc1.42E01E\')) {\r\n                return \'probably\'\r\n            }\r\n        }\r\n        // This mimetype is only supported if no codecs are specified\r\n        if (mime === \'audio/x-m4a\' && !codecs.length) {\r\n            return \'maybe\'\r\n        }\r\n\r\n        // This mimetype is only supported if no codecs are specified\r\n        if (mime === \'audio/aac\' && !codecs.length) {\r\n            return \'probably\'\r\n        }\r\n        // Everything else as usual\r\n        return target.apply(ctx, args)\r\n    }\r\n}\r\n\r\n/* global HTMLMediaElement */\r\nutils.replaceWithProxy(\r\n    HTMLMediaElement.prototype,\r\n    \'canPlayType\',\r\n    canPlayType\r\n)', 'navigator_vendor': "Object.defineProperty(Object.getPrototypeOf(navigator), 'vendor', {\r\n    get: () => opts.navigator_vendor || 'Google Inc.',\r\n})\r\n", 'navigator_plugins': 'data = {\r\n    "mimeTypes": [\r\n        {\r\n            "type": "application/pdf",\r\n            "suffixes": "pdf",\r\n            "description": "",\r\n            "__pluginName": "Chrome PDF Viewer"\r\n        },\r\n        {\r\n            "type": "application/x-google-chrome-pdf",\r\n            "suffixes": "pdf",\r\n            "description": "Portable Document Format",\r\n            "__pluginName": "Chrome PDF Plugin"\r\n        },\r\n        {\r\n            "type": "application/x-nacl",\r\n            "suffixes": "",\r\n            "description": "Native Client Executable",\r\n            "__pluginName": "Native Client"\r\n        },\r\n        {\r\n            "type": "application/x-pnacl",\r\n            "suffixes": "",\r\n            "description": "Portable Native Client Executable",\r\n            "__pluginName": "Native Client"\r\n        }\r\n    ],\r\n    "plugins": [\r\n        {\r\n            "name": "Chrome PDF Plugin",\r\n            "filename": "internal-pdf-viewer",\r\n            "description": "Portable Document Format",\r\n            "__mimeTypes": ["application/x-google-chrome-pdf"]\r\n        },\r\n        {\r\n            "name": "Chrome PDF Viewer",\r\n            "filename": "mhjfbmdgcfjbbpaeojofohoefgiehjai",\r\n            "description": "",\r\n            "__mimeTypes": ["application/pdf"]\r\n        },\r\n        {\r\n            "name": "Native Client",\r\n            "filename": "internal-nacl-plugin",\r\n            "description": "",\r\n            "__mimeTypes": ["application/x-nacl", "application/x-pnacl"]\r\n        }\r\n    ]\r\n}\r\n\r\n\r\n// That means we\'re running headful\r\nconst hasPlugins = \'plugins\' in navigator && navigator.plugins.length\r\nif (!(hasPlugins)) {\r\n\r\n    const mimeTypes = generateMagicArray(\r\n        data.mimeTypes,\r\n        MimeTypeArray.prototype,\r\n        MimeType.prototype,\r\n        \'type\'\r\n    )\r\n    const plugins = generateMagicArray(\r\n        data.plugins,\r\n        PluginArray.prototype,\r\n        Plugin.prototype,\r\n        \'name\'\r\n    )\r\n\r\n    // Plugin and MimeType cross-reference each other, let\'s do that now\r\n    // Note: We\'re looping through `data.plugins` here, not the generated `plugins`\r\n    for (const pluginData of data.plugins) {\r\n        pluginData.__mimeTypes.forEach((type, index) => {\r\n            plugins[pluginData.name][index] = mimeTypes[type]\r\n            plugins[type] = mimeTypes[type]\r\n            Object.defineProperty(mimeTypes[type], \'enabledPlugin\', {\r\n                value: JSON.parse(JSON.stringify(plugins[pluginData.name])),\r\n                writable: false,\r\n                enumerable: false, // Important: `JSON.stringify(navigator.plugins)`\r\n                configurable: false\r\n            })\r\n        })\r\n    }\r\n\r\n    const patchNavigator = (name, value) =>\r\n        utils.replaceProperty(Object.getPrototypeOf(navigator), name, {\r\n            get() {\r\n                return value\r\n            }\r\n        })\r\n\r\n    patchNavigator(\'mimeTypes\', mimeTypes)\r\n    patchNavigator(\'plugins\', plugins)\r\n}', 'navigator_permissions': "const handler = {\r\n    apply: function (target, ctx, args) {\r\n        const param = (args || [])[0]\r\n\r\n        if (param && param.name && param.name === 'notifications') {\r\n            const result = {state: Notification.permission}\r\n            Object.setPrototypeOf(result, PermissionStatus.prototype)\r\n            return Promise.resolve(result)\r\n        }\r\n\r\n        return utils.cache.Reflect.apply(...arguments)\r\n    }\r\n}\r\n\r\nutils.replaceWithProxy(\r\n    window.navigator.permissions.__proto__, // eslint-disable-line no-proto\r\n    'query',\r\n    handler\r\n)\r\n", 'navigator_languages': "Object.defineProperty(Object.getPrototypeOf(navigator), 'languages', {\r\n    get: () => opts.languages || ['en-US', 'en']\r\n})\r\n", 'navigator_platform': "if (opts.navigator_platform) {\r\n    Object.defineProperty(Object.getPrototypeOf(navigator), 'platform', {\r\n        get: () => opts.navigator_plaftorm,\r\n    })\r\n}", 'navigator_user_agent': "// replace Headless references in default useragent\r\nconst current_ua = navigator.userAgent\r\nObject.defineProperty(Object.getPrototypeOf(navigator), 'userAgent', {\r\n    get: () => opts.navigator_user_agent || current_ua.replace('HeadlessChrome/', 'Chrome/')\r\n})\r\n", 'navigator_hardware_concurrency': "const patchNavigator = (name, value) =>\r\n    utils.replaceProperty(Object.getPrototypeOf(navigator), name, {\r\n        get() {\r\n            return value\r\n        }\r\n    })\r\n\r\npatchNavigator('hardwareConcurrency', opts.navigator_hardware_concurrency || 4);", 'outerdimensions': "'use strict'\r\n\r\ntry {\r\n    if (!!window.outerWidth && !!window.outerHeight) {\r\n        const windowFrame = 85 // probably OS and WM dependent\r\n        window.outerWidth = window.innerWidth\r\n        console.log(`current window outer height ${window.outerHeight}`)\r\n        window.outerHeight = window.innerHeight + windowFrame\r\n        console.log(`new window outer height ${window.outerHeight}`)\r\n    }\r\n} catch (err) {\r\n}\r\n", 'utils': '/**\r\n * A set of shared utility functions specifically for the purpose of modifying native browser APIs without leaving traces.\r\n *\r\n * Meant to be passed down in puppeteer and used in the context of the page (everything in here runs in NodeJS as well as a browser).\r\n *\r\n * Note: If for whatever reason you need to use this outside of `puppeteer-extra`:\r\n * Just remove the `module.exports` statement at the very bottom, the rest can be copy pasted into any browser context.\r\n *\r\n * Alternatively take a look at the `extract-stealth-evasions` package to create a finished bundle which includes these utilities.\r\n *\r\n */\r\nconst utils = {}\r\n\r\n/**\r\n * Wraps a JS Proxy Handler and strips it\'s presence from error stacks, in case the traps throw.\r\n *\r\n * The presence of a JS Proxy can be revealed as it shows up in error stack traces.\r\n *\r\n * @param {object} handler - The JS Proxy handler to wrap\r\n */\r\nutils.stripProxyFromErrors = (handler = {}) => {\r\n  const newHandler = {}\r\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\r\n  const traps = Object.getOwnPropertyNames(handler)\r\n  traps.forEach(trap => {\r\n    newHandler[trap] = function() {\r\n      try {\r\n        // Forward the call to the defined proxy handler\r\n        return handler[trap].apply(this, arguments || [])\r\n      } catch (err) {\r\n        // Stack traces differ per browser, we only support chromium based ones currently\r\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\r\n          throw err\r\n        }\r\n\r\n        // When something throws within one of our traps the Proxy will show up in error stacks\r\n        // An earlier implementation of this code would simply strip lines with a blacklist,\r\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\r\n        // We try to use a known "anchor" line for that and strip it with everything above it.\r\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\r\n\r\n        const stripWithBlacklist = stack => {\r\n          const blacklist = [\r\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\r\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\r\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\r\n          ]\r\n          return (\r\n            err.stack\r\n              .split(\'\\n\')\r\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\r\n              .filter((line, index) => index !== 1)\r\n              // Check if the line starts with one of our blacklisted strings\r\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\r\n              .join(\'\\n\')\r\n          )\r\n        }\r\n\r\n        const stripWithAnchor = stack => {\r\n          const stackArr = stack.split(\'\\n\')\r\n          const anchor = `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\r\n          const anchorIndex = stackArr.findIndex(line =>\r\n            line.trim().startsWith(anchor)\r\n          )\r\n          if (anchorIndex === -1) {\r\n            return false // 404, anchor not found\r\n          }\r\n          // Strip everything from the top until we reach the anchor line\r\n          // Note: We\'re keeping the 1st line (zero index) as it\'s unrelated (e.g. `TypeError`)\r\n          stackArr.splice(1, anchorIndex)\r\n          return stackArr.join(\'\\n\')\r\n        }\r\n\r\n        // Try using the anchor method, fallback to blacklist if necessary\r\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\r\n\r\n        throw err // Re-throw our now sanitized error\r\n      }\r\n    }\r\n  })\r\n  return newHandler\r\n}\r\n\r\n/**\r\n * Strip error lines from stack traces until (and including) a known line the stack.\r\n *\r\n * @param {object} err - The error to sanitize\r\n * @param {string} anchor - The string the anchor line starts with\r\n */\r\nutils.stripErrorWithAnchor = (err, anchor) => {\r\n  const stackArr = err.stack.split(\'\\n\')\r\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\r\n  if (anchorIndex === -1) {\r\n    return err // 404, anchor not found\r\n  }\r\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\r\n  // Note: We\'re keeping the 1st line (zero index) as it\'s unrelated (e.g. `TypeError`)\r\n  stackArr.splice(1, anchorIndex)\r\n  err.stack = stackArr.join(\'\\n\')\r\n  return err\r\n}\r\n\r\n/**\r\n * Replace the property of an object in a stealthy way.\r\n *\r\n * Note: You also want to work on the prototype of an object most often,\r\n * as you\'d otherwise leave traces (e.g. showing up in Object.getOwnPropertyNames(obj)).\r\n *\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\r\n *\r\n * @example\r\n * replaceProperty(WebGLRenderingContext.prototype, \'getParameter\', { value: "alice" })\r\n * // or\r\n * replaceProperty(Object.getPrototypeOf(navigator), \'languages\', { get: () => [\'en-US\', \'en\'] })\r\n *\r\n * @param {object} obj - The object which has the property to replace\r\n * @param {string} propName - The property name to replace\r\n * @param {object} descriptorOverrides - e.g. { value: "alice" }\r\n */\r\nutils.replaceProperty = (obj, propName, descriptorOverrides = {}) => {\r\n  return Object.defineProperty(obj, propName, {\r\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\r\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\r\n    // Add our overrides (e.g. value, get())\r\n    ...descriptorOverrides\r\n  })\r\n}\r\n\r\n/**\r\n * Preload a cache of function copies and data.\r\n *\r\n * For a determined enough observer it would be possible to overwrite and sniff usage of functions\r\n * we use in our internal Proxies, to combat that we use a cached copy of those functions.\r\n *\r\n * This is evaluated once per execution context (e.g. window)\r\n */\r\nutils.preloadCache = () => {\r\n  if (utils.cache) {\r\n    return\r\n  }\r\n  utils.cache = {\r\n    // Used in our proxies\r\n    Reflect: {\r\n      get: Reflect.get.bind(Reflect),\r\n      apply: Reflect.apply.bind(Reflect)\r\n    },\r\n    // Used in `makeNativeString`\r\n    nativeToStringStr: Function.toString + \'\' // => `function toString() { [native code] }`\r\n  }\r\n}\r\n\r\n/**\r\n * Utility function to generate a cross-browser `toString` result representing native code.\r\n *\r\n * There\'s small differences: Chromium uses a single line, whereas FF & Webkit uses multiline strings.\r\n * To future-proof this we use an existing native toString result as the basis.\r\n *\r\n * The only advantage we have over the other team is that our JS runs first, hence we cache the result\r\n * of the native toString result once, so they cannot spoof it afterwards and reveal that we\'re using it.\r\n *\r\n * Note: Whenever we add a `Function.prototype.toString` proxy we should preload the cache before,\r\n * by executing `utils.preloadCache()` before the proxy is applied (so we don\'t cause recursive lookups).\r\n *\r\n * @example\r\n * makeNativeString(\'foobar\') // => `function foobar() { [native code] }`\r\n *\r\n * @param {string} [name] - Optional function name\r\n */\r\nutils.makeNativeString = (name = \'\') => {\r\n  // Cache (per-window) the original native toString or use that if available\r\n  utils.preloadCache()\r\n  return utils.cache.nativeToStringStr.replace(\'toString\', name || \'\')\r\n}\r\n\r\n/**\r\n * Helper function to modify the `toString()` result of the provided object.\r\n *\r\n * Note: Use `utils.redirectToString` instead when possible.\r\n *\r\n * There\'s a quirk in JS Proxies that will cause the `toString()` result to differ from the vanilla Object.\r\n * If no string is provided we will generate a `[native code]` thing based on the name of the property object.\r\n *\r\n * @example\r\n * patchToString(WebGLRenderingContext.prototype.getParameter, \'function getParameter() { [native code] }\')\r\n *\r\n * @param {object} obj - The object for which to modify the `toString()` representation\r\n * @param {string} str - Optional string used as a return value\r\n */\r\nutils.patchToString = (obj, str = \'\') => {\r\n  utils.preloadCache()\r\n\r\n  const toStringProxy = new Proxy(Function.prototype.toString, {\r\n    apply: function(target, ctx) {\r\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + ""`\r\n      if (ctx === Function.prototype.toString) {\r\n        return utils.makeNativeString(\'toString\')\r\n      }\r\n      // `toString` targeted at our proxied Object detected\r\n      if (ctx === obj) {\r\n        // We either return the optional string verbatim or derive the most desired result automatically\r\n        return str || utils.makeNativeString(obj.name)\r\n      }\r\n      // Check if the toString protype of the context is the same as the global prototype,\r\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\r\n      const hasSameProto = Object.getPrototypeOf(\r\n        Function.prototype.toString\r\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\r\n      if (!hasSameProto) {\r\n        // Pass the call on to the local Function.prototype.toString instead\r\n        return ctx.toString()\r\n      }\r\n      return target.call(ctx)\r\n    }\r\n  })\r\n  utils.replaceProperty(Function.prototype, \'toString\', {\r\n    value: toStringProxy\r\n  })\r\n}\r\n\r\n/**\r\n * Make all nested functions of an object native.\r\n *\r\n * @param {object} obj\r\n */\r\nutils.patchToStringNested = (obj = {}) => {\r\n  return utils.execRecursively(obj, [\'function\'], utils.patchToString)\r\n}\r\n\r\n/**\r\n * Redirect toString requests from one object to another.\r\n *\r\n * @param {object} proxyObj - The object that toString will be called on\r\n * @param {object} originalObj - The object which toString result we wan to return\r\n */\r\nutils.redirectToString = (proxyObj, originalObj) => {\r\n  utils.preloadCache()\r\n\r\n  const toStringProxy = new Proxy(Function.prototype.toString, {\r\n    apply: function(target, ctx) {\r\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + ""`\r\n      if (ctx === Function.prototype.toString) {\r\n        return utils.makeNativeString(\'toString\')\r\n      }\r\n\r\n      // `toString` targeted at our proxied Object detected\r\n      if (ctx === proxyObj) {\r\n        const fallback = () =>\r\n          originalObj && originalObj.name\r\n            ? utils.makeNativeString(originalObj.name)\r\n            : utils.makeNativeString(proxyObj.name)\r\n\r\n        // Return the toString representation of our original object if possible\r\n        return originalObj + \'\' || fallback()\r\n      }\r\n\r\n      // Check if the toString protype of the context is the same as the global prototype,\r\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\r\n      const hasSameProto = Object.getPrototypeOf(\r\n        Function.prototype.toString\r\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\r\n      if (!hasSameProto) {\r\n        // Pass the call on to the local Function.prototype.toString instead\r\n        return ctx.toString()\r\n      }\r\n\r\n      return target.call(ctx)\r\n    }\r\n  })\r\n  utils.replaceProperty(Function.prototype, \'toString\', {\r\n    value: toStringProxy\r\n  })\r\n}\r\n\r\n/**\r\n * All-in-one method to replace a property with a JS Proxy using the provided Proxy handler with traps.\r\n *\r\n * Will stealthify these aspects (strip error stack traces, redirect toString, etc).\r\n * Note: This is meant to modify native Browser APIs and works best with prototype objects.\r\n *\r\n * @example\r\n * replaceWithProxy(WebGLRenderingContext.prototype, \'getParameter\', proxyHandler)\r\n *\r\n * @param {object} obj - The object which has the property to replace\r\n * @param {string} propName - The name of the property to replace\r\n * @param {object} handler - The JS Proxy handler to use\r\n */\r\nutils.replaceWithProxy = (obj, propName, handler) => {\r\n  utils.preloadCache()\r\n  const originalObj = obj[propName]\r\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\r\n\r\n  utils.replaceProperty(obj, propName, { value: proxyObj })\r\n  utils.redirectToString(proxyObj, originalObj)\r\n\r\n  return true\r\n}\r\n\r\n/**\r\n * All-in-one method to mock a non-existing property with a JS Proxy using the provided Proxy handler with traps.\r\n *\r\n * Will stealthify these aspects (strip error stack traces, redirect toString, etc).\r\n *\r\n * @example\r\n * mockWithProxy(chrome.runtime, \'sendMessage\', function sendMessage() {}, proxyHandler)\r\n *\r\n * @param {object} obj - The object which has the property to replace\r\n * @param {string} propName - The name of the property to replace or create\r\n * @param {object} pseudoTarget - The JS Proxy target to use as a basis\r\n * @param {object} handler - The JS Proxy handler to use\r\n */\r\nutils.mockWithProxy = (obj, propName, pseudoTarget, handler) => {\r\n  utils.preloadCache()\r\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\r\n\r\n  utils.replaceProperty(obj, propName, { value: proxyObj })\r\n  utils.patchToString(proxyObj)\r\n\r\n  return true\r\n}\r\n\r\n/**\r\n * All-in-one method to create a new JS Proxy with stealth tweaks.\r\n *\r\n * This is meant to be used whenever we need a JS Proxy but don\'t want to replace or mock an existing known property.\r\n *\r\n * Will stealthify certain aspects of the Proxy (strip error stack traces, redirect toString, etc).\r\n *\r\n * @example\r\n * createProxy(navigator.mimeTypes.__proto__.namedItem, proxyHandler) // => Proxy\r\n *\r\n * @param {object} pseudoTarget - The JS Proxy target to use as a basis\r\n * @param {object} handler - The JS Proxy handler to use\r\n */\r\nutils.createProxy = (pseudoTarget, handler) => {\r\n  utils.preloadCache()\r\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\r\n  utils.patchToString(proxyObj)\r\n\r\n  return proxyObj\r\n}\r\n\r\n/**\r\n * Helper function to split a full path to an Object into the first part and property.\r\n *\r\n * @example\r\n * splitObjPath(`HTMLMediaElement.prototype.canPlayType`)\r\n * // => {objName: "HTMLMediaElement.prototype", propName: "canPlayType"}\r\n *\r\n * @param {string} objPath - The full path to an object as dot notation string\r\n */\r\nutils.splitObjPath = objPath => ({\r\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\r\n  objName: objPath\r\n    .split(\'.\')\r\n    .slice(0, -1)\r\n    .join(\'.\'),\r\n  // Extract last dot entry ==> `canPlayType`\r\n  propName: objPath.split(\'.\').slice(-1)[0]\r\n})\r\n\r\n/**\r\n * Convenience method to replace a property with a JS Proxy using the provided objPath.\r\n *\r\n * Supports a full path (dot notation) to the object as string here, in case that makes it easier.\r\n *\r\n * @example\r\n * replaceObjPathWithProxy(\'WebGLRenderingContext.prototype.getParameter\', proxyHandler)\r\n *\r\n * @param {string} objPath - The full path to an object (dot notation string) to replace\r\n * @param {object} handler - The JS Proxy handler to use\r\n */\r\nutils.replaceObjPathWithProxy = (objPath, handler) => {\r\n  const { objName, propName } = utils.splitObjPath(objPath)\r\n  const obj = eval(objName) // eslint-disable-line no-eval\r\n  return utils.replaceWithProxy(obj, propName, handler)\r\n}\r\n\r\n/**\r\n * Traverse nested properties of an object recursively and apply the given function on a whitelist of value types.\r\n *\r\n * @param {object} obj\r\n * @param {array} typeFilter - e.g. `[\'function\']`\r\n * @param {Function} fn - e.g. `utils.patchToString`\r\n */\r\nutils.execRecursively = (obj = {}, typeFilter = [], fn) => {\r\n  function recurse(obj) {\r\n    for (const key in obj) {\r\n      if (obj[key] === undefined) {\r\n        continue\r\n      }\r\n      if (obj[key] && typeof obj[key] === \'object\') {\r\n        recurse(obj[key])\r\n      } else {\r\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\r\n          fn.call(this, obj[key])\r\n        }\r\n      }\r\n    }\r\n  }\r\n  recurse(obj)\r\n  return obj\r\n}\r\n\r\n/**\r\n * Everything we run through e.g. `page.evaluate` runs in the browser context, not the NodeJS one.\r\n * That means we cannot just use reference variables and functions from outside code, we need to pass everything as a parameter.\r\n *\r\n * Unfortunately the data we can pass is only allowed to be of primitive types, regular functions don\'t survive the built-in serialization process.\r\n * This utility function will take an object with functions and stringify them, so we can pass them down unharmed as strings.\r\n *\r\n * We use this to pass down our utility functions as well as any other functions (to be able to split up code better).\r\n *\r\n * @see utils.materializeFns\r\n *\r\n * @param {object} fnObj - An object containing functions as properties\r\n */\r\nutils.stringifyFns = (fnObj = { hello: () => \'world\' }) => {\r\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\r\n  // https://github.com/feross/fromentries\r\n  function fromEntries(iterable) {\r\n    return [...iterable].reduce((obj, [key, val]) => {\r\n      obj[key] = val\r\n      return obj\r\n    }, {})\r\n  }\r\n  return (Object.fromEntries || fromEntries)(\r\n    Object.entries(fnObj)\r\n      .filter(([key, value]) => typeof value === \'function\')\r\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\r\n  )\r\n}\r\n\r\n/**\r\n * Utility function to reverse the process of `utils.stringifyFns`.\r\n * Will materialize an object with stringified functions (supports classic and fat arrow functions).\r\n *\r\n * @param {object} fnStrObj - An object containing stringified functions as properties\r\n */\r\nutils.materializeFns = (fnStrObj = { hello: "() => \'world\'" }) => {\r\n  return Object.fromEntries(\r\n    Object.entries(fnStrObj).map(([key, value]) => {\r\n      if (value.startsWith(\'function\')) {\r\n        // some trickery is needed to make oldschool functions work :-)\r\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\r\n      } else {\r\n        // arrow functions just work\r\n        return [key, eval(value)] // eslint-disable-line no-eval\r\n      }\r\n    })\r\n  )\r\n}\r\n\r\n// --\r\n// Stuff starting below this line is NodeJS specific.\r\n// --\r\n// module.exports = utils', 'webdriver': 'delete Object.getPrototypeOf(navigator).webdriver', 'webgl_vendor': "console.log(opts)\r\nconst getParameterProxyHandler = {\r\n    apply: function (target, ctx, args) {\r\n        const param = (args || [])[0]\r\n        // UNMASKED_VENDOR_WEBGL\r\n        if (param === 37445) {\r\n            return opts.webgl_vendor || 'Intel Inc.' // default in headless: Google Inc.\r\n        }\r\n        // UNMASKED_RENDERER_WEBGL\r\n        if (param === 37446) {\r\n            return opts.webgl_renderer || 'Intel Iris OpenGL Engine' // default in headless: Google SwiftShader\r\n        }\r\n        return utils.cache.Reflect.apply(target, ctx, args)\r\n    }\r\n}\r\n\r\n// There's more than one WebGL rendering context\r\n// https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext#Browser_compatibility\r\n// To find out the original values here: Object.getOwnPropertyDescriptors(WebGLRenderingContext.prototype.getParameter)\r\nconst addProxy = (obj, propName) => {\r\n    utils.replaceWithProxy(obj, propName, getParameterProxyHandler)\r\n}\r\n// For whatever weird reason loops don't play nice with Object.defineProperty, here's the next best thing:\r\naddProxy(WebGLRenderingContext.prototype, 'getParameter')\r\naddProxy(WebGL2RenderingContext.prototype, 'getParameter')"}